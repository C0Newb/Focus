/*


	Username, password -> Validate password -> Create runtime session & (if requested) persistentHash (and signature)



	RunTime hash:
		[hash]: random 256 character string, username involved (seed?)
		[sig]: hash of the above & browser_identifier + encrypted using a public key (thus signed)

	PersistentHash:
		[hash]: random 512 character string, username involved (seed?)
		[sig]: hash of the above & browser_identifier + encrypted using a unique key (thus "signed")



	If both the public and private keys are secured and unknown publicly, then there should be no way to forge a signature. And without a forged signature the server will not accept the hash (token).


	The RunTime hash is like a temporary API key. We save those in an array, [hash] = { user: username, creationTime: dateAndTime }, and trust them fully (as long as the signature matches).
	On server restart or after X period from the creationTime we disregard that RunTimeHash. A new one must be generated by logging back in or using the PersistentHash.
	There are two versions of this hash: a strong version and a weak version. The strong version is the same level as logging in via username & password. The weak version is, well, weaker.
	It can not be used to manage 'sensitive' settings or access 'secure' functions. A RunTimeHash can not be promoted, but we can issue a new strong hash after re-authenticating the user.


	The PersistentHash is stored with the user's account details. To save time, provide the username with the PersistentHash when validating. As long as the signature matches, we trust this hash fully.
	Multiple PersistentHashes are able to be stored for a user (sessions). After validating a PersistentHash, we regenerate one and destroy the old one. Any time we access a 'secure' function, regenerate this hash.
	Additionally, whenever we use this hash to log the user in we'll return a 'weak' RunTimeHash. 




	RHash (Runtime Hash):
		+ hash: random 256 character string (shared between server and client)
		+ signature: the above hashed (sha512) and then hashed again (sha256) with "key" (shared between server and client)
		- key: a random 512 character string that is used as a salt to hash our signature (only known by the server)
		- username: Who owns this.
		- creationTime: Date and time when this was generated. ** RHashes are valid for 2 hours. ***

	RHashes *should* be impossible to fabricate, but they *could* be stolen from memory.
		[
			For example:
				John has logged into our system and is issued a RHash. Herald can come by and yank John's key. Now that Herald knows John's hash and signature, all he has to do is send these to the server and the server sees him as John.
				One way to prevent this is by using some identification that could not be copied/mimicked by Herald. One solution is to have a second signature where the user (John) would "sign" the original hash using a public/private key pair.
				John's OS (or browser) would encrypt (sign) the hash with it's private key, and then send the server their new signature and public key. This would work amazing, however, currently browsers do not support this. Sorta.
		]
	Using a key to "sign" the original hash is totally overkill and only further prevents someone from generating a fake RHash, which is already ridiculously hard.

	PHash (Persistent Hash):
		+ hash: random 1024 character string (shared between server and client)
		+ signature: the above hashed (sha512) and then hashed again (sha512) with "key" (shared between server and client)
		- key: a random 512 character string that is used as a salt to hash our signature (only known by the server)
		- username: Who owns this.
		- creationTime: Date and time when this was generated.

*/

/*

	Account:
		username: the username ...
		password: the hashed password (token)
		firstName: first name ...
		lastName: last name ...
		emailAddress: email address (for password resets)
		phoneNumber: substitute to the email address (for password resets)
		shoots: [] array list of shoots we have interacted with


*/

/*

	Shoot:
		id: 
		title:
		description:
		
		shareSettings: {
			
		}

		images: [
			"IMG_XXXX_CNCO" // The image name (file name, minus extension) 
		]

*/


/*
	API Calls:
		pbkdf2:
			hashPassword(password, callback): Hash the password "password" and then return it to the callback function "callback"
			verifyPassword(token, checkPassword): Check that "token" is the encrypted version of "checkPassword"

*/


/*
	
	Photo storage:
		data/shoots/<shoot_title>/<image_name>.jpg
	
		Image links: /images/:shootID/:imageID-:quality?<security options>
			Security options can include:
				yes

		thumbnail link: /images/:shootID/:imageID.thumbnail
			(original quality, ~250x250)

		low quality link: /images/:shootID/:imageID.low
			(at least 720p, 75% quality)

		med quality link: /images/:shootID/:imageID.medium
			(at least 1080p, 85% quality)

		high quality link: /images/:shootID/:imageID.high
			(at least 1440p, 85% quality)

		originalQuality: /images/:shootID/:imageID.original
			(... original ...)

		ZIP: /zip/:shoot/quality/:quality
			Only images you have access to will be zipped

	If the shoot or image does not exist, you'll get a 404 error.
	If your security options are invalid, do not match, or are missing, you'll get a 403 error.


	Old:
		thumbnail link: /images/tN?shoot=<shoot_title>&image=<image_name>
			(original quality, ~250x250)

		low quality link: /images/lQ?shoot=<shoot_title>&image=<image_name>
			(at least 720p, 75% quality)

		med quality link: /images/mQ?shoot=<shoot_title>&image=<image_name>
			(at least 1080p, 85% quality)

		high quality link: /images/mQ?shoot=<shoot_title>&image=<image_name>
			(at least 1440p, 85% quality)

		originalQuality: /images/original?shoot=<shoot_title>&image=<image_name>
			(... original ...)

*/